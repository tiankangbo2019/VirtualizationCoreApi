// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: qigrpc.proto
#ifndef GRPC_qigrpc_2eproto__INCLUDED
#define GRPC_qigrpc_2eproto__INCLUDED

#include "qigrpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace Qigrpc {

// 指定服务名称,作为生成代码中的二级namespace
class Server final {
 public:
  static constexpr char const* service_full_name() {
    return "Qigrpc.Server";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // 测试接口
    virtual ::grpc::Status Test(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::Qigrpc::vcaReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> AsyncTest(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(AsyncTestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> PrepareAsyncTest(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(PrepareAsyncTestRaw(context, request, cq));
    }
    // 获取主机信息
    virtual ::grpc::Status HostInfo(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::Qigrpc::vcaReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> AsyncHostInfo(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(AsyncHostInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> PrepareAsyncHostInfo(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(PrepareAsyncHostInfoRaw(context, request, cq));
    }
    // 虚拟机装机
    virtual ::grpc::Status VmInstall(::grpc::ClientContext* context, const ::Qigrpc::requestInstall& request, ::Qigrpc::vcaReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> AsyncVmInstall(::grpc::ClientContext* context, const ::Qigrpc::requestInstall& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(AsyncVmInstallRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> PrepareAsyncVmInstall(::grpc::ClientContext* context, const ::Qigrpc::requestInstall& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(PrepareAsyncVmInstallRaw(context, request, cq));
    }
    // 虚拟机的普通操作服务<API-002-009>
    virtual ::grpc::Status VmCommon(::grpc::ClientContext* context, const ::Qigrpc::requestSimple& request, ::Qigrpc::vcaReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> AsyncVmCommon(::grpc::ClientContext* context, const ::Qigrpc::requestSimple& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(AsyncVmCommonRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> PrepareAsyncVmCommon(::grpc::ClientContext* context, const ::Qigrpc::requestSimple& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(PrepareAsyncVmCommonRaw(context, request, cq));
    }
    // 虚拟机的快照
    virtual ::grpc::Status VmOperateSnapshot(::grpc::ClientContext* context, const ::Qigrpc::requestSnapshot& request, ::Qigrpc::vcaReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> AsyncVmOperateSnapshot(::grpc::ClientContext* context, const ::Qigrpc::requestSnapshot& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(AsyncVmOperateSnapshotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> PrepareAsyncVmOperateSnapshot(::grpc::ClientContext* context, const ::Qigrpc::requestSnapshot& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(PrepareAsyncVmOperateSnapshotRaw(context, request, cq));
    }
    // 虚拟机的克隆
    virtual ::grpc::Status VmClone(::grpc::ClientContext* context, const ::Qigrpc::requestClone& request, ::Qigrpc::vcaReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> AsyncVmClone(::grpc::ClientContext* context, const ::Qigrpc::requestClone& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(AsyncVmCloneRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> PrepareAsyncVmClone(::grpc::ClientContext* context, const ::Qigrpc::requestClone& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(PrepareAsyncVmCloneRaw(context, request, cq));
    }
    // 虚拟机导入&导出
    virtual ::grpc::Status VmImpAndExp(::grpc::ClientContext* context, const ::Qigrpc::requestImpAndexportVM& request, ::Qigrpc::vcaReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> AsyncVmImpAndExp(::grpc::ClientContext* context, const ::Qigrpc::requestImpAndexportVM& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(AsyncVmImpAndExpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> PrepareAsyncVmImpAndExp(::grpc::ClientContext* context, const ::Qigrpc::requestImpAndexportVM& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(PrepareAsyncVmImpAndExpRaw(context, request, cq));
    }
    // 虚拟机网卡设置
    virtual ::grpc::Status VmNetwork(::grpc::ClientContext* context, const ::Qigrpc::requestNetwork& request, ::Qigrpc::vcaReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> AsyncVmNetwork(::grpc::ClientContext* context, const ::Qigrpc::requestNetwork& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(AsyncVmNetworkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> PrepareAsyncVmNetwork(::grpc::ClientContext* context, const ::Qigrpc::requestNetwork& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(PrepareAsyncVmNetworkRaw(context, request, cq));
    }
    // 虚拟机rdp
    virtual ::grpc::Status VmRdp(::grpc::ClientContext* context, const ::Qigrpc::requestRdp& request, ::Qigrpc::vcaReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> AsyncVmRdp(::grpc::ClientContext* context, const ::Qigrpc::requestRdp& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(AsyncVmRdpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> PrepareAsyncVmRdp(::grpc::ClientContext* context, const ::Qigrpc::requestRdp& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(PrepareAsyncVmRdpRaw(context, request, cq));
    }
    // 虚拟机录屏幕
    virtual ::grpc::Status VmRecord(::grpc::ClientContext* context, const ::Qigrpc::requestRecord& request, ::Qigrpc::vcaReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> AsyncVmRecord(::grpc::ClientContext* context, const ::Qigrpc::requestRecord& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(AsyncVmRecordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> PrepareAsyncVmRecord(::grpc::ClientContext* context, const ::Qigrpc::requestRecord& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(PrepareAsyncVmRecordRaw(context, request, cq));
    }
    // 虚拟机共享文件夹
    virtual ::grpc::Status VmSharefolder(::grpc::ClientContext* context, const ::Qigrpc::requestSharefolder& request, ::Qigrpc::vcaReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> AsyncVmSharefolder(::grpc::ClientContext* context, const ::Qigrpc::requestSharefolder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(AsyncVmSharefolderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> PrepareAsyncVmSharefolder(::grpc::ClientContext* context, const ::Qigrpc::requestSharefolder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(PrepareAsyncVmSharefolderRaw(context, request, cq));
    }
    // 虚拟机cpu，内存，显卡配置
    virtual ::grpc::Status VmConfig(::grpc::ClientContext* context, const ::Qigrpc::requestConfig& request, ::Qigrpc::vcaReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> AsyncVmConfig(::grpc::ClientContext* context, const ::Qigrpc::requestConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(AsyncVmConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> PrepareAsyncVmConfig(::grpc::ClientContext* context, const ::Qigrpc::requestConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(PrepareAsyncVmConfigRaw(context, request, cq));
    }
    // 虚拟机usb
    virtual ::grpc::Status VmUSB(::grpc::ClientContext* context, const ::Qigrpc::requestUSB& request, ::Qigrpc::vcaReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> AsyncVmUSB(::grpc::ClientContext* context, const ::Qigrpc::requestUSB& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(AsyncVmUSBRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> PrepareAsyncVmUSB(::grpc::ClientContext* context, const ::Qigrpc::requestUSB& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(PrepareAsyncVmUSBRaw(context, request, cq));
    }
    // 虚拟机声卡
    virtual ::grpc::Status VmAudio(::grpc::ClientContext* context, const ::Qigrpc::requestAudio& request, ::Qigrpc::vcaReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> AsyncVmAudio(::grpc::ClientContext* context, const ::Qigrpc::requestAudio& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(AsyncVmAudioRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> PrepareAsyncVmAudio(::grpc::ClientContext* context, const ::Qigrpc::requestAudio& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(PrepareAsyncVmAudioRaw(context, request, cq));
    }
    // 虚拟机串口
    virtual ::grpc::Status VmSerial(::grpc::ClientContext* context, const ::Qigrpc::requestSerial& request, ::Qigrpc::vcaReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> AsyncVmSerial(::grpc::ClientContext* context, const ::Qigrpc::requestSerial& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(AsyncVmSerialRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> PrepareAsyncVmSerial(::grpc::ClientContext* context, const ::Qigrpc::requestSerial& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(PrepareAsyncVmSerialRaw(context, request, cq));
    }
    // p2p接口
    virtual ::grpc::Status P2P(::grpc::ClientContext* context, const ::Qigrpc::requestP2P& request, ::Qigrpc::vcaReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> AsyncP2P(::grpc::ClientContext* context, const ::Qigrpc::requestP2P& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(AsyncP2PRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> PrepareAsyncP2P(::grpc::ClientContext* context, const ::Qigrpc::requestP2P& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(PrepareAsyncP2PRaw(context, request, cq));
    }
    // requestVmExtends接口:创建磁盘;附加磁盘
    virtual ::grpc::Status VmExtends(::grpc::ClientContext* context, const ::Qigrpc::requestVmExtends& request, ::Qigrpc::vcaReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> AsyncVmExtends(::grpc::ClientContext* context, const ::Qigrpc::requestVmExtends& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(AsyncVmExtendsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>> PrepareAsyncVmExtends(::grpc::ClientContext* context, const ::Qigrpc::requestVmExtends& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>>(PrepareAsyncVmExtendsRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // 测试接口
      virtual void Test(::grpc::ClientContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Test(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      // 获取主机信息
      virtual void HostInfo(::grpc::ClientContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HostInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      // 虚拟机装机
      virtual void VmInstall(::grpc::ClientContext* context, const ::Qigrpc::requestInstall* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VmInstall(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      // 虚拟机的普通操作服务<API-002-009>
      virtual void VmCommon(::grpc::ClientContext* context, const ::Qigrpc::requestSimple* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VmCommon(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      // 虚拟机的快照
      virtual void VmOperateSnapshot(::grpc::ClientContext* context, const ::Qigrpc::requestSnapshot* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VmOperateSnapshot(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      // 虚拟机的克隆
      virtual void VmClone(::grpc::ClientContext* context, const ::Qigrpc::requestClone* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VmClone(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      // 虚拟机导入&导出
      virtual void VmImpAndExp(::grpc::ClientContext* context, const ::Qigrpc::requestImpAndexportVM* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VmImpAndExp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      // 虚拟机网卡设置
      virtual void VmNetwork(::grpc::ClientContext* context, const ::Qigrpc::requestNetwork* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VmNetwork(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      // 虚拟机rdp
      virtual void VmRdp(::grpc::ClientContext* context, const ::Qigrpc::requestRdp* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VmRdp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      // 虚拟机录屏幕
      virtual void VmRecord(::grpc::ClientContext* context, const ::Qigrpc::requestRecord* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VmRecord(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      // 虚拟机共享文件夹
      virtual void VmSharefolder(::grpc::ClientContext* context, const ::Qigrpc::requestSharefolder* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VmSharefolder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      // 虚拟机cpu，内存，显卡配置
      virtual void VmConfig(::grpc::ClientContext* context, const ::Qigrpc::requestConfig* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VmConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      // 虚拟机usb
      virtual void VmUSB(::grpc::ClientContext* context, const ::Qigrpc::requestUSB* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VmUSB(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      // 虚拟机声卡
      virtual void VmAudio(::grpc::ClientContext* context, const ::Qigrpc::requestAudio* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VmAudio(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      // 虚拟机串口
      virtual void VmSerial(::grpc::ClientContext* context, const ::Qigrpc::requestSerial* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VmSerial(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      // p2p接口
      virtual void P2P(::grpc::ClientContext* context, const ::Qigrpc::requestP2P* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void P2P(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      // requestVmExtends接口:创建磁盘;附加磁盘
      virtual void VmExtends(::grpc::ClientContext* context, const ::Qigrpc::requestVmExtends* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VmExtends(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* AsyncTestRaw(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* PrepareAsyncTestRaw(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* AsyncHostInfoRaw(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* PrepareAsyncHostInfoRaw(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* AsyncVmInstallRaw(::grpc::ClientContext* context, const ::Qigrpc::requestInstall& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* PrepareAsyncVmInstallRaw(::grpc::ClientContext* context, const ::Qigrpc::requestInstall& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* AsyncVmCommonRaw(::grpc::ClientContext* context, const ::Qigrpc::requestSimple& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* PrepareAsyncVmCommonRaw(::grpc::ClientContext* context, const ::Qigrpc::requestSimple& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* AsyncVmOperateSnapshotRaw(::grpc::ClientContext* context, const ::Qigrpc::requestSnapshot& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* PrepareAsyncVmOperateSnapshotRaw(::grpc::ClientContext* context, const ::Qigrpc::requestSnapshot& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* AsyncVmCloneRaw(::grpc::ClientContext* context, const ::Qigrpc::requestClone& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* PrepareAsyncVmCloneRaw(::grpc::ClientContext* context, const ::Qigrpc::requestClone& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* AsyncVmImpAndExpRaw(::grpc::ClientContext* context, const ::Qigrpc::requestImpAndexportVM& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* PrepareAsyncVmImpAndExpRaw(::grpc::ClientContext* context, const ::Qigrpc::requestImpAndexportVM& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* AsyncVmNetworkRaw(::grpc::ClientContext* context, const ::Qigrpc::requestNetwork& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* PrepareAsyncVmNetworkRaw(::grpc::ClientContext* context, const ::Qigrpc::requestNetwork& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* AsyncVmRdpRaw(::grpc::ClientContext* context, const ::Qigrpc::requestRdp& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* PrepareAsyncVmRdpRaw(::grpc::ClientContext* context, const ::Qigrpc::requestRdp& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* AsyncVmRecordRaw(::grpc::ClientContext* context, const ::Qigrpc::requestRecord& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* PrepareAsyncVmRecordRaw(::grpc::ClientContext* context, const ::Qigrpc::requestRecord& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* AsyncVmSharefolderRaw(::grpc::ClientContext* context, const ::Qigrpc::requestSharefolder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* PrepareAsyncVmSharefolderRaw(::grpc::ClientContext* context, const ::Qigrpc::requestSharefolder& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* AsyncVmConfigRaw(::grpc::ClientContext* context, const ::Qigrpc::requestConfig& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* PrepareAsyncVmConfigRaw(::grpc::ClientContext* context, const ::Qigrpc::requestConfig& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* AsyncVmUSBRaw(::grpc::ClientContext* context, const ::Qigrpc::requestUSB& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* PrepareAsyncVmUSBRaw(::grpc::ClientContext* context, const ::Qigrpc::requestUSB& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* AsyncVmAudioRaw(::grpc::ClientContext* context, const ::Qigrpc::requestAudio& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* PrepareAsyncVmAudioRaw(::grpc::ClientContext* context, const ::Qigrpc::requestAudio& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* AsyncVmSerialRaw(::grpc::ClientContext* context, const ::Qigrpc::requestSerial& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* PrepareAsyncVmSerialRaw(::grpc::ClientContext* context, const ::Qigrpc::requestSerial& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* AsyncP2PRaw(::grpc::ClientContext* context, const ::Qigrpc::requestP2P& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* PrepareAsyncP2PRaw(::grpc::ClientContext* context, const ::Qigrpc::requestP2P& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* AsyncVmExtendsRaw(::grpc::ClientContext* context, const ::Qigrpc::requestVmExtends& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Qigrpc::vcaReply>* PrepareAsyncVmExtendsRaw(::grpc::ClientContext* context, const ::Qigrpc::requestVmExtends& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Test(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::Qigrpc::vcaReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> AsyncTest(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(AsyncTestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> PrepareAsyncTest(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(PrepareAsyncTestRaw(context, request, cq));
    }
    ::grpc::Status HostInfo(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::Qigrpc::vcaReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> AsyncHostInfo(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(AsyncHostInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> PrepareAsyncHostInfo(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(PrepareAsyncHostInfoRaw(context, request, cq));
    }
    ::grpc::Status VmInstall(::grpc::ClientContext* context, const ::Qigrpc::requestInstall& request, ::Qigrpc::vcaReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> AsyncVmInstall(::grpc::ClientContext* context, const ::Qigrpc::requestInstall& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(AsyncVmInstallRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> PrepareAsyncVmInstall(::grpc::ClientContext* context, const ::Qigrpc::requestInstall& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(PrepareAsyncVmInstallRaw(context, request, cq));
    }
    ::grpc::Status VmCommon(::grpc::ClientContext* context, const ::Qigrpc::requestSimple& request, ::Qigrpc::vcaReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> AsyncVmCommon(::grpc::ClientContext* context, const ::Qigrpc::requestSimple& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(AsyncVmCommonRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> PrepareAsyncVmCommon(::grpc::ClientContext* context, const ::Qigrpc::requestSimple& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(PrepareAsyncVmCommonRaw(context, request, cq));
    }
    ::grpc::Status VmOperateSnapshot(::grpc::ClientContext* context, const ::Qigrpc::requestSnapshot& request, ::Qigrpc::vcaReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> AsyncVmOperateSnapshot(::grpc::ClientContext* context, const ::Qigrpc::requestSnapshot& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(AsyncVmOperateSnapshotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> PrepareAsyncVmOperateSnapshot(::grpc::ClientContext* context, const ::Qigrpc::requestSnapshot& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(PrepareAsyncVmOperateSnapshotRaw(context, request, cq));
    }
    ::grpc::Status VmClone(::grpc::ClientContext* context, const ::Qigrpc::requestClone& request, ::Qigrpc::vcaReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> AsyncVmClone(::grpc::ClientContext* context, const ::Qigrpc::requestClone& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(AsyncVmCloneRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> PrepareAsyncVmClone(::grpc::ClientContext* context, const ::Qigrpc::requestClone& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(PrepareAsyncVmCloneRaw(context, request, cq));
    }
    ::grpc::Status VmImpAndExp(::grpc::ClientContext* context, const ::Qigrpc::requestImpAndexportVM& request, ::Qigrpc::vcaReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> AsyncVmImpAndExp(::grpc::ClientContext* context, const ::Qigrpc::requestImpAndexportVM& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(AsyncVmImpAndExpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> PrepareAsyncVmImpAndExp(::grpc::ClientContext* context, const ::Qigrpc::requestImpAndexportVM& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(PrepareAsyncVmImpAndExpRaw(context, request, cq));
    }
    ::grpc::Status VmNetwork(::grpc::ClientContext* context, const ::Qigrpc::requestNetwork& request, ::Qigrpc::vcaReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> AsyncVmNetwork(::grpc::ClientContext* context, const ::Qigrpc::requestNetwork& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(AsyncVmNetworkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> PrepareAsyncVmNetwork(::grpc::ClientContext* context, const ::Qigrpc::requestNetwork& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(PrepareAsyncVmNetworkRaw(context, request, cq));
    }
    ::grpc::Status VmRdp(::grpc::ClientContext* context, const ::Qigrpc::requestRdp& request, ::Qigrpc::vcaReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> AsyncVmRdp(::grpc::ClientContext* context, const ::Qigrpc::requestRdp& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(AsyncVmRdpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> PrepareAsyncVmRdp(::grpc::ClientContext* context, const ::Qigrpc::requestRdp& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(PrepareAsyncVmRdpRaw(context, request, cq));
    }
    ::grpc::Status VmRecord(::grpc::ClientContext* context, const ::Qigrpc::requestRecord& request, ::Qigrpc::vcaReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> AsyncVmRecord(::grpc::ClientContext* context, const ::Qigrpc::requestRecord& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(AsyncVmRecordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> PrepareAsyncVmRecord(::grpc::ClientContext* context, const ::Qigrpc::requestRecord& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(PrepareAsyncVmRecordRaw(context, request, cq));
    }
    ::grpc::Status VmSharefolder(::grpc::ClientContext* context, const ::Qigrpc::requestSharefolder& request, ::Qigrpc::vcaReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> AsyncVmSharefolder(::grpc::ClientContext* context, const ::Qigrpc::requestSharefolder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(AsyncVmSharefolderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> PrepareAsyncVmSharefolder(::grpc::ClientContext* context, const ::Qigrpc::requestSharefolder& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(PrepareAsyncVmSharefolderRaw(context, request, cq));
    }
    ::grpc::Status VmConfig(::grpc::ClientContext* context, const ::Qigrpc::requestConfig& request, ::Qigrpc::vcaReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> AsyncVmConfig(::grpc::ClientContext* context, const ::Qigrpc::requestConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(AsyncVmConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> PrepareAsyncVmConfig(::grpc::ClientContext* context, const ::Qigrpc::requestConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(PrepareAsyncVmConfigRaw(context, request, cq));
    }
    ::grpc::Status VmUSB(::grpc::ClientContext* context, const ::Qigrpc::requestUSB& request, ::Qigrpc::vcaReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> AsyncVmUSB(::grpc::ClientContext* context, const ::Qigrpc::requestUSB& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(AsyncVmUSBRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> PrepareAsyncVmUSB(::grpc::ClientContext* context, const ::Qigrpc::requestUSB& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(PrepareAsyncVmUSBRaw(context, request, cq));
    }
    ::grpc::Status VmAudio(::grpc::ClientContext* context, const ::Qigrpc::requestAudio& request, ::Qigrpc::vcaReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> AsyncVmAudio(::grpc::ClientContext* context, const ::Qigrpc::requestAudio& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(AsyncVmAudioRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> PrepareAsyncVmAudio(::grpc::ClientContext* context, const ::Qigrpc::requestAudio& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(PrepareAsyncVmAudioRaw(context, request, cq));
    }
    ::grpc::Status VmSerial(::grpc::ClientContext* context, const ::Qigrpc::requestSerial& request, ::Qigrpc::vcaReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> AsyncVmSerial(::grpc::ClientContext* context, const ::Qigrpc::requestSerial& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(AsyncVmSerialRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> PrepareAsyncVmSerial(::grpc::ClientContext* context, const ::Qigrpc::requestSerial& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(PrepareAsyncVmSerialRaw(context, request, cq));
    }
    ::grpc::Status P2P(::grpc::ClientContext* context, const ::Qigrpc::requestP2P& request, ::Qigrpc::vcaReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> AsyncP2P(::grpc::ClientContext* context, const ::Qigrpc::requestP2P& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(AsyncP2PRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> PrepareAsyncP2P(::grpc::ClientContext* context, const ::Qigrpc::requestP2P& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(PrepareAsyncP2PRaw(context, request, cq));
    }
    ::grpc::Status VmExtends(::grpc::ClientContext* context, const ::Qigrpc::requestVmExtends& request, ::Qigrpc::vcaReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> AsyncVmExtends(::grpc::ClientContext* context, const ::Qigrpc::requestVmExtends& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(AsyncVmExtendsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>> PrepareAsyncVmExtends(::grpc::ClientContext* context, const ::Qigrpc::requestVmExtends& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>>(PrepareAsyncVmExtendsRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Test(::grpc::ClientContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void Test(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void HostInfo(::grpc::ClientContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void HostInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmInstall(::grpc::ClientContext* context, const ::Qigrpc::requestInstall* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmInstall(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmCommon(::grpc::ClientContext* context, const ::Qigrpc::requestSimple* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmCommon(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmOperateSnapshot(::grpc::ClientContext* context, const ::Qigrpc::requestSnapshot* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmOperateSnapshot(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmClone(::grpc::ClientContext* context, const ::Qigrpc::requestClone* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmClone(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmImpAndExp(::grpc::ClientContext* context, const ::Qigrpc::requestImpAndexportVM* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmImpAndExp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmNetwork(::grpc::ClientContext* context, const ::Qigrpc::requestNetwork* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmNetwork(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmRdp(::grpc::ClientContext* context, const ::Qigrpc::requestRdp* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmRdp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmRecord(::grpc::ClientContext* context, const ::Qigrpc::requestRecord* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmRecord(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmSharefolder(::grpc::ClientContext* context, const ::Qigrpc::requestSharefolder* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmSharefolder(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmConfig(::grpc::ClientContext* context, const ::Qigrpc::requestConfig* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmUSB(::grpc::ClientContext* context, const ::Qigrpc::requestUSB* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmUSB(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmAudio(::grpc::ClientContext* context, const ::Qigrpc::requestAudio* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmAudio(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmSerial(::grpc::ClientContext* context, const ::Qigrpc::requestSerial* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmSerial(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void P2P(::grpc::ClientContext* context, const ::Qigrpc::requestP2P* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void P2P(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmExtends(::grpc::ClientContext* context, const ::Qigrpc::requestVmExtends* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
      void VmExtends(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Qigrpc::vcaReply* response, std::function<void(::grpc::Status)>) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* AsyncTestRaw(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* PrepareAsyncTestRaw(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* AsyncHostInfoRaw(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* PrepareAsyncHostInfoRaw(::grpc::ClientContext* context, const ::Qigrpc::requestNull& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* AsyncVmInstallRaw(::grpc::ClientContext* context, const ::Qigrpc::requestInstall& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* PrepareAsyncVmInstallRaw(::grpc::ClientContext* context, const ::Qigrpc::requestInstall& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* AsyncVmCommonRaw(::grpc::ClientContext* context, const ::Qigrpc::requestSimple& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* PrepareAsyncVmCommonRaw(::grpc::ClientContext* context, const ::Qigrpc::requestSimple& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* AsyncVmOperateSnapshotRaw(::grpc::ClientContext* context, const ::Qigrpc::requestSnapshot& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* PrepareAsyncVmOperateSnapshotRaw(::grpc::ClientContext* context, const ::Qigrpc::requestSnapshot& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* AsyncVmCloneRaw(::grpc::ClientContext* context, const ::Qigrpc::requestClone& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* PrepareAsyncVmCloneRaw(::grpc::ClientContext* context, const ::Qigrpc::requestClone& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* AsyncVmImpAndExpRaw(::grpc::ClientContext* context, const ::Qigrpc::requestImpAndexportVM& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* PrepareAsyncVmImpAndExpRaw(::grpc::ClientContext* context, const ::Qigrpc::requestImpAndexportVM& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* AsyncVmNetworkRaw(::grpc::ClientContext* context, const ::Qigrpc::requestNetwork& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* PrepareAsyncVmNetworkRaw(::grpc::ClientContext* context, const ::Qigrpc::requestNetwork& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* AsyncVmRdpRaw(::grpc::ClientContext* context, const ::Qigrpc::requestRdp& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* PrepareAsyncVmRdpRaw(::grpc::ClientContext* context, const ::Qigrpc::requestRdp& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* AsyncVmRecordRaw(::grpc::ClientContext* context, const ::Qigrpc::requestRecord& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* PrepareAsyncVmRecordRaw(::grpc::ClientContext* context, const ::Qigrpc::requestRecord& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* AsyncVmSharefolderRaw(::grpc::ClientContext* context, const ::Qigrpc::requestSharefolder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* PrepareAsyncVmSharefolderRaw(::grpc::ClientContext* context, const ::Qigrpc::requestSharefolder& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* AsyncVmConfigRaw(::grpc::ClientContext* context, const ::Qigrpc::requestConfig& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* PrepareAsyncVmConfigRaw(::grpc::ClientContext* context, const ::Qigrpc::requestConfig& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* AsyncVmUSBRaw(::grpc::ClientContext* context, const ::Qigrpc::requestUSB& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* PrepareAsyncVmUSBRaw(::grpc::ClientContext* context, const ::Qigrpc::requestUSB& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* AsyncVmAudioRaw(::grpc::ClientContext* context, const ::Qigrpc::requestAudio& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* PrepareAsyncVmAudioRaw(::grpc::ClientContext* context, const ::Qigrpc::requestAudio& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* AsyncVmSerialRaw(::grpc::ClientContext* context, const ::Qigrpc::requestSerial& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* PrepareAsyncVmSerialRaw(::grpc::ClientContext* context, const ::Qigrpc::requestSerial& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* AsyncP2PRaw(::grpc::ClientContext* context, const ::Qigrpc::requestP2P& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* PrepareAsyncP2PRaw(::grpc::ClientContext* context, const ::Qigrpc::requestP2P& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* AsyncVmExtendsRaw(::grpc::ClientContext* context, const ::Qigrpc::requestVmExtends& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Qigrpc::vcaReply>* PrepareAsyncVmExtendsRaw(::grpc::ClientContext* context, const ::Qigrpc::requestVmExtends& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Test_;
    const ::grpc::internal::RpcMethod rpcmethod_HostInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_VmInstall_;
    const ::grpc::internal::RpcMethod rpcmethod_VmCommon_;
    const ::grpc::internal::RpcMethod rpcmethod_VmOperateSnapshot_;
    const ::grpc::internal::RpcMethod rpcmethod_VmClone_;
    const ::grpc::internal::RpcMethod rpcmethod_VmImpAndExp_;
    const ::grpc::internal::RpcMethod rpcmethod_VmNetwork_;
    const ::grpc::internal::RpcMethod rpcmethod_VmRdp_;
    const ::grpc::internal::RpcMethod rpcmethod_VmRecord_;
    const ::grpc::internal::RpcMethod rpcmethod_VmSharefolder_;
    const ::grpc::internal::RpcMethod rpcmethod_VmConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_VmUSB_;
    const ::grpc::internal::RpcMethod rpcmethod_VmAudio_;
    const ::grpc::internal::RpcMethod rpcmethod_VmSerial_;
    const ::grpc::internal::RpcMethod rpcmethod_P2P_;
    const ::grpc::internal::RpcMethod rpcmethod_VmExtends_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // 测试接口
    virtual ::grpc::Status Test(::grpc::ServerContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response);
    // 获取主机信息
    virtual ::grpc::Status HostInfo(::grpc::ServerContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response);
    // 虚拟机装机
    virtual ::grpc::Status VmInstall(::grpc::ServerContext* context, const ::Qigrpc::requestInstall* request, ::Qigrpc::vcaReply* response);
    // 虚拟机的普通操作服务<API-002-009>
    virtual ::grpc::Status VmCommon(::grpc::ServerContext* context, const ::Qigrpc::requestSimple* request, ::Qigrpc::vcaReply* response);
    // 虚拟机的快照
    virtual ::grpc::Status VmOperateSnapshot(::grpc::ServerContext* context, const ::Qigrpc::requestSnapshot* request, ::Qigrpc::vcaReply* response);
    // 虚拟机的克隆
    virtual ::grpc::Status VmClone(::grpc::ServerContext* context, const ::Qigrpc::requestClone* request, ::Qigrpc::vcaReply* response);
    // 虚拟机导入&导出
    virtual ::grpc::Status VmImpAndExp(::grpc::ServerContext* context, const ::Qigrpc::requestImpAndexportVM* request, ::Qigrpc::vcaReply* response);
    // 虚拟机网卡设置
    virtual ::grpc::Status VmNetwork(::grpc::ServerContext* context, const ::Qigrpc::requestNetwork* request, ::Qigrpc::vcaReply* response);
    // 虚拟机rdp
    virtual ::grpc::Status VmRdp(::grpc::ServerContext* context, const ::Qigrpc::requestRdp* request, ::Qigrpc::vcaReply* response);
    // 虚拟机录屏幕
    virtual ::grpc::Status VmRecord(::grpc::ServerContext* context, const ::Qigrpc::requestRecord* request, ::Qigrpc::vcaReply* response);
    // 虚拟机共享文件夹
    virtual ::grpc::Status VmSharefolder(::grpc::ServerContext* context, const ::Qigrpc::requestSharefolder* request, ::Qigrpc::vcaReply* response);
    // 虚拟机cpu，内存，显卡配置
    virtual ::grpc::Status VmConfig(::grpc::ServerContext* context, const ::Qigrpc::requestConfig* request, ::Qigrpc::vcaReply* response);
    // 虚拟机usb
    virtual ::grpc::Status VmUSB(::grpc::ServerContext* context, const ::Qigrpc::requestUSB* request, ::Qigrpc::vcaReply* response);
    // 虚拟机声卡
    virtual ::grpc::Status VmAudio(::grpc::ServerContext* context, const ::Qigrpc::requestAudio* request, ::Qigrpc::vcaReply* response);
    // 虚拟机串口
    virtual ::grpc::Status VmSerial(::grpc::ServerContext* context, const ::Qigrpc::requestSerial* request, ::Qigrpc::vcaReply* response);
    // p2p接口
    virtual ::grpc::Status P2P(::grpc::ServerContext* context, const ::Qigrpc::requestP2P* request, ::Qigrpc::vcaReply* response);
    // requestVmExtends接口:创建磁盘;附加磁盘
    virtual ::grpc::Status VmExtends(::grpc::ServerContext* context, const ::Qigrpc::requestVmExtends* request, ::Qigrpc::vcaReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Test : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Test() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Test() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Test(::grpc::ServerContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTest(::grpc::ServerContext* context, ::Qigrpc::requestNull* request, ::grpc::ServerAsyncResponseWriter< ::Qigrpc::vcaReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HostInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_HostInfo() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_HostInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HostInfo(::grpc::ServerContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHostInfo(::grpc::ServerContext* context, ::Qigrpc::requestNull* request, ::grpc::ServerAsyncResponseWriter< ::Qigrpc::vcaReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VmInstall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VmInstall() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_VmInstall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmInstall(::grpc::ServerContext* context, const ::Qigrpc::requestInstall* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmInstall(::grpc::ServerContext* context, ::Qigrpc::requestInstall* request, ::grpc::ServerAsyncResponseWriter< ::Qigrpc::vcaReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VmCommon : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VmCommon() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_VmCommon() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmCommon(::grpc::ServerContext* context, const ::Qigrpc::requestSimple* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmCommon(::grpc::ServerContext* context, ::Qigrpc::requestSimple* request, ::grpc::ServerAsyncResponseWriter< ::Qigrpc::vcaReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VmOperateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VmOperateSnapshot() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_VmOperateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmOperateSnapshot(::grpc::ServerContext* context, const ::Qigrpc::requestSnapshot* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmOperateSnapshot(::grpc::ServerContext* context, ::Qigrpc::requestSnapshot* request, ::grpc::ServerAsyncResponseWriter< ::Qigrpc::vcaReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VmClone : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VmClone() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_VmClone() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmClone(::grpc::ServerContext* context, const ::Qigrpc::requestClone* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmClone(::grpc::ServerContext* context, ::Qigrpc::requestClone* request, ::grpc::ServerAsyncResponseWriter< ::Qigrpc::vcaReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VmImpAndExp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VmImpAndExp() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_VmImpAndExp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmImpAndExp(::grpc::ServerContext* context, const ::Qigrpc::requestImpAndexportVM* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmImpAndExp(::grpc::ServerContext* context, ::Qigrpc::requestImpAndexportVM* request, ::grpc::ServerAsyncResponseWriter< ::Qigrpc::vcaReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VmNetwork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VmNetwork() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_VmNetwork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmNetwork(::grpc::ServerContext* context, const ::Qigrpc::requestNetwork* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmNetwork(::grpc::ServerContext* context, ::Qigrpc::requestNetwork* request, ::grpc::ServerAsyncResponseWriter< ::Qigrpc::vcaReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VmRdp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VmRdp() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_VmRdp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmRdp(::grpc::ServerContext* context, const ::Qigrpc::requestRdp* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmRdp(::grpc::ServerContext* context, ::Qigrpc::requestRdp* request, ::grpc::ServerAsyncResponseWriter< ::Qigrpc::vcaReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VmRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VmRecord() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_VmRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmRecord(::grpc::ServerContext* context, const ::Qigrpc::requestRecord* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmRecord(::grpc::ServerContext* context, ::Qigrpc::requestRecord* request, ::grpc::ServerAsyncResponseWriter< ::Qigrpc::vcaReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VmSharefolder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VmSharefolder() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_VmSharefolder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmSharefolder(::grpc::ServerContext* context, const ::Qigrpc::requestSharefolder* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmSharefolder(::grpc::ServerContext* context, ::Qigrpc::requestSharefolder* request, ::grpc::ServerAsyncResponseWriter< ::Qigrpc::vcaReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VmConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VmConfig() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_VmConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmConfig(::grpc::ServerContext* context, const ::Qigrpc::requestConfig* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmConfig(::grpc::ServerContext* context, ::Qigrpc::requestConfig* request, ::grpc::ServerAsyncResponseWriter< ::Qigrpc::vcaReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VmUSB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VmUSB() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_VmUSB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmUSB(::grpc::ServerContext* context, const ::Qigrpc::requestUSB* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmUSB(::grpc::ServerContext* context, ::Qigrpc::requestUSB* request, ::grpc::ServerAsyncResponseWriter< ::Qigrpc::vcaReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VmAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VmAudio() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_VmAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmAudio(::grpc::ServerContext* context, const ::Qigrpc::requestAudio* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmAudio(::grpc::ServerContext* context, ::Qigrpc::requestAudio* request, ::grpc::ServerAsyncResponseWriter< ::Qigrpc::vcaReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VmSerial : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VmSerial() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_VmSerial() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmSerial(::grpc::ServerContext* context, const ::Qigrpc::requestSerial* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmSerial(::grpc::ServerContext* context, ::Qigrpc::requestSerial* request, ::grpc::ServerAsyncResponseWriter< ::Qigrpc::vcaReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_P2P : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_P2P() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_P2P() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2P(::grpc::ServerContext* context, const ::Qigrpc::requestP2P* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestP2P(::grpc::ServerContext* context, ::Qigrpc::requestP2P* request, ::grpc::ServerAsyncResponseWriter< ::Qigrpc::vcaReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VmExtends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_VmExtends() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_VmExtends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmExtends(::grpc::ServerContext* context, const ::Qigrpc::requestVmExtends* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmExtends(::grpc::ServerContext* context, ::Qigrpc::requestVmExtends* request, ::grpc::ServerAsyncResponseWriter< ::Qigrpc::vcaReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Test<WithAsyncMethod_HostInfo<WithAsyncMethod_VmInstall<WithAsyncMethod_VmCommon<WithAsyncMethod_VmOperateSnapshot<WithAsyncMethod_VmClone<WithAsyncMethod_VmImpAndExp<WithAsyncMethod_VmNetwork<WithAsyncMethod_VmRdp<WithAsyncMethod_VmRecord<WithAsyncMethod_VmSharefolder<WithAsyncMethod_VmConfig<WithAsyncMethod_VmUSB<WithAsyncMethod_VmAudio<WithAsyncMethod_VmSerial<WithAsyncMethod_P2P<WithAsyncMethod_VmExtends<Service > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Test : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Test() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::Qigrpc::requestNull, ::Qigrpc::vcaReply>(
          [this](::grpc::ServerContext* context,
                 const ::Qigrpc::requestNull* request,
                 ::Qigrpc::vcaReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Test(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_Test() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Test(::grpc::ServerContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Test(::grpc::ServerContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_HostInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_HostInfo() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::Qigrpc::requestNull, ::Qigrpc::vcaReply>(
          [this](::grpc::ServerContext* context,
                 const ::Qigrpc::requestNull* request,
                 ::Qigrpc::vcaReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->HostInfo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_HostInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HostInfo(::grpc::ServerContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void HostInfo(::grpc::ServerContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VmInstall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VmInstall() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::Qigrpc::requestInstall, ::Qigrpc::vcaReply>(
          [this](::grpc::ServerContext* context,
                 const ::Qigrpc::requestInstall* request,
                 ::Qigrpc::vcaReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VmInstall(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_VmInstall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmInstall(::grpc::ServerContext* context, const ::Qigrpc::requestInstall* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmInstall(::grpc::ServerContext* context, const ::Qigrpc::requestInstall* request, ::Qigrpc::vcaReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VmCommon : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VmCommon() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::Qigrpc::requestSimple, ::Qigrpc::vcaReply>(
          [this](::grpc::ServerContext* context,
                 const ::Qigrpc::requestSimple* request,
                 ::Qigrpc::vcaReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VmCommon(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_VmCommon() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmCommon(::grpc::ServerContext* context, const ::Qigrpc::requestSimple* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmCommon(::grpc::ServerContext* context, const ::Qigrpc::requestSimple* request, ::Qigrpc::vcaReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VmOperateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VmOperateSnapshot() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::Qigrpc::requestSnapshot, ::Qigrpc::vcaReply>(
          [this](::grpc::ServerContext* context,
                 const ::Qigrpc::requestSnapshot* request,
                 ::Qigrpc::vcaReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VmOperateSnapshot(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_VmOperateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmOperateSnapshot(::grpc::ServerContext* context, const ::Qigrpc::requestSnapshot* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmOperateSnapshot(::grpc::ServerContext* context, const ::Qigrpc::requestSnapshot* request, ::Qigrpc::vcaReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VmClone : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VmClone() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::Qigrpc::requestClone, ::Qigrpc::vcaReply>(
          [this](::grpc::ServerContext* context,
                 const ::Qigrpc::requestClone* request,
                 ::Qigrpc::vcaReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VmClone(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_VmClone() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmClone(::grpc::ServerContext* context, const ::Qigrpc::requestClone* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmClone(::grpc::ServerContext* context, const ::Qigrpc::requestClone* request, ::Qigrpc::vcaReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VmImpAndExp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VmImpAndExp() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::Qigrpc::requestImpAndexportVM, ::Qigrpc::vcaReply>(
          [this](::grpc::ServerContext* context,
                 const ::Qigrpc::requestImpAndexportVM* request,
                 ::Qigrpc::vcaReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VmImpAndExp(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_VmImpAndExp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmImpAndExp(::grpc::ServerContext* context, const ::Qigrpc::requestImpAndexportVM* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmImpAndExp(::grpc::ServerContext* context, const ::Qigrpc::requestImpAndexportVM* request, ::Qigrpc::vcaReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VmNetwork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VmNetwork() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::Qigrpc::requestNetwork, ::Qigrpc::vcaReply>(
          [this](::grpc::ServerContext* context,
                 const ::Qigrpc::requestNetwork* request,
                 ::Qigrpc::vcaReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VmNetwork(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_VmNetwork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmNetwork(::grpc::ServerContext* context, const ::Qigrpc::requestNetwork* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmNetwork(::grpc::ServerContext* context, const ::Qigrpc::requestNetwork* request, ::Qigrpc::vcaReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VmRdp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VmRdp() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::Qigrpc::requestRdp, ::Qigrpc::vcaReply>(
          [this](::grpc::ServerContext* context,
                 const ::Qigrpc::requestRdp* request,
                 ::Qigrpc::vcaReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VmRdp(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_VmRdp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmRdp(::grpc::ServerContext* context, const ::Qigrpc::requestRdp* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmRdp(::grpc::ServerContext* context, const ::Qigrpc::requestRdp* request, ::Qigrpc::vcaReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VmRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VmRecord() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::Qigrpc::requestRecord, ::Qigrpc::vcaReply>(
          [this](::grpc::ServerContext* context,
                 const ::Qigrpc::requestRecord* request,
                 ::Qigrpc::vcaReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VmRecord(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_VmRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmRecord(::grpc::ServerContext* context, const ::Qigrpc::requestRecord* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmRecord(::grpc::ServerContext* context, const ::Qigrpc::requestRecord* request, ::Qigrpc::vcaReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VmSharefolder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VmSharefolder() {
      ::grpc::Service::experimental().MarkMethodCallback(10,
        new ::grpc::internal::CallbackUnaryHandler< ::Qigrpc::requestSharefolder, ::Qigrpc::vcaReply>(
          [this](::grpc::ServerContext* context,
                 const ::Qigrpc::requestSharefolder* request,
                 ::Qigrpc::vcaReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VmSharefolder(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_VmSharefolder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmSharefolder(::grpc::ServerContext* context, const ::Qigrpc::requestSharefolder* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmSharefolder(::grpc::ServerContext* context, const ::Qigrpc::requestSharefolder* request, ::Qigrpc::vcaReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VmConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VmConfig() {
      ::grpc::Service::experimental().MarkMethodCallback(11,
        new ::grpc::internal::CallbackUnaryHandler< ::Qigrpc::requestConfig, ::Qigrpc::vcaReply>(
          [this](::grpc::ServerContext* context,
                 const ::Qigrpc::requestConfig* request,
                 ::Qigrpc::vcaReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VmConfig(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_VmConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmConfig(::grpc::ServerContext* context, const ::Qigrpc::requestConfig* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmConfig(::grpc::ServerContext* context, const ::Qigrpc::requestConfig* request, ::Qigrpc::vcaReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VmUSB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VmUSB() {
      ::grpc::Service::experimental().MarkMethodCallback(12,
        new ::grpc::internal::CallbackUnaryHandler< ::Qigrpc::requestUSB, ::Qigrpc::vcaReply>(
          [this](::grpc::ServerContext* context,
                 const ::Qigrpc::requestUSB* request,
                 ::Qigrpc::vcaReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VmUSB(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_VmUSB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmUSB(::grpc::ServerContext* context, const ::Qigrpc::requestUSB* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmUSB(::grpc::ServerContext* context, const ::Qigrpc::requestUSB* request, ::Qigrpc::vcaReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VmAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VmAudio() {
      ::grpc::Service::experimental().MarkMethodCallback(13,
        new ::grpc::internal::CallbackUnaryHandler< ::Qigrpc::requestAudio, ::Qigrpc::vcaReply>(
          [this](::grpc::ServerContext* context,
                 const ::Qigrpc::requestAudio* request,
                 ::Qigrpc::vcaReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VmAudio(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_VmAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmAudio(::grpc::ServerContext* context, const ::Qigrpc::requestAudio* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmAudio(::grpc::ServerContext* context, const ::Qigrpc::requestAudio* request, ::Qigrpc::vcaReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VmSerial : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VmSerial() {
      ::grpc::Service::experimental().MarkMethodCallback(14,
        new ::grpc::internal::CallbackUnaryHandler< ::Qigrpc::requestSerial, ::Qigrpc::vcaReply>(
          [this](::grpc::ServerContext* context,
                 const ::Qigrpc::requestSerial* request,
                 ::Qigrpc::vcaReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VmSerial(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_VmSerial() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmSerial(::grpc::ServerContext* context, const ::Qigrpc::requestSerial* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmSerial(::grpc::ServerContext* context, const ::Qigrpc::requestSerial* request, ::Qigrpc::vcaReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_P2P : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_P2P() {
      ::grpc::Service::experimental().MarkMethodCallback(15,
        new ::grpc::internal::CallbackUnaryHandler< ::Qigrpc::requestP2P, ::Qigrpc::vcaReply>(
          [this](::grpc::ServerContext* context,
                 const ::Qigrpc::requestP2P* request,
                 ::Qigrpc::vcaReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->P2P(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_P2P() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2P(::grpc::ServerContext* context, const ::Qigrpc::requestP2P* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void P2P(::grpc::ServerContext* context, const ::Qigrpc::requestP2P* request, ::Qigrpc::vcaReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VmExtends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_VmExtends() {
      ::grpc::Service::experimental().MarkMethodCallback(16,
        new ::grpc::internal::CallbackUnaryHandler< ::Qigrpc::requestVmExtends, ::Qigrpc::vcaReply>(
          [this](::grpc::ServerContext* context,
                 const ::Qigrpc::requestVmExtends* request,
                 ::Qigrpc::vcaReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->VmExtends(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithCallbackMethod_VmExtends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmExtends(::grpc::ServerContext* context, const ::Qigrpc::requestVmExtends* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmExtends(::grpc::ServerContext* context, const ::Qigrpc::requestVmExtends* request, ::Qigrpc::vcaReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_Test<ExperimentalWithCallbackMethod_HostInfo<ExperimentalWithCallbackMethod_VmInstall<ExperimentalWithCallbackMethod_VmCommon<ExperimentalWithCallbackMethod_VmOperateSnapshot<ExperimentalWithCallbackMethod_VmClone<ExperimentalWithCallbackMethod_VmImpAndExp<ExperimentalWithCallbackMethod_VmNetwork<ExperimentalWithCallbackMethod_VmRdp<ExperimentalWithCallbackMethod_VmRecord<ExperimentalWithCallbackMethod_VmSharefolder<ExperimentalWithCallbackMethod_VmConfig<ExperimentalWithCallbackMethod_VmUSB<ExperimentalWithCallbackMethod_VmAudio<ExperimentalWithCallbackMethod_VmSerial<ExperimentalWithCallbackMethod_P2P<ExperimentalWithCallbackMethod_VmExtends<Service > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Test : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Test() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Test() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Test(::grpc::ServerContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HostInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_HostInfo() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_HostInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HostInfo(::grpc::ServerContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VmInstall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VmInstall() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_VmInstall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmInstall(::grpc::ServerContext* context, const ::Qigrpc::requestInstall* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VmCommon : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VmCommon() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_VmCommon() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmCommon(::grpc::ServerContext* context, const ::Qigrpc::requestSimple* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VmOperateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VmOperateSnapshot() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_VmOperateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmOperateSnapshot(::grpc::ServerContext* context, const ::Qigrpc::requestSnapshot* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VmClone : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VmClone() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_VmClone() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmClone(::grpc::ServerContext* context, const ::Qigrpc::requestClone* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VmImpAndExp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VmImpAndExp() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_VmImpAndExp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmImpAndExp(::grpc::ServerContext* context, const ::Qigrpc::requestImpAndexportVM* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VmNetwork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VmNetwork() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_VmNetwork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmNetwork(::grpc::ServerContext* context, const ::Qigrpc::requestNetwork* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VmRdp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VmRdp() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_VmRdp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmRdp(::grpc::ServerContext* context, const ::Qigrpc::requestRdp* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VmRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VmRecord() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_VmRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmRecord(::grpc::ServerContext* context, const ::Qigrpc::requestRecord* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VmSharefolder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VmSharefolder() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_VmSharefolder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmSharefolder(::grpc::ServerContext* context, const ::Qigrpc::requestSharefolder* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VmConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VmConfig() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_VmConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmConfig(::grpc::ServerContext* context, const ::Qigrpc::requestConfig* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VmUSB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VmUSB() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_VmUSB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmUSB(::grpc::ServerContext* context, const ::Qigrpc::requestUSB* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VmAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VmAudio() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_VmAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmAudio(::grpc::ServerContext* context, const ::Qigrpc::requestAudio* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VmSerial : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VmSerial() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_VmSerial() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmSerial(::grpc::ServerContext* context, const ::Qigrpc::requestSerial* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_P2P : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_P2P() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_P2P() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2P(::grpc::ServerContext* context, const ::Qigrpc::requestP2P* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VmExtends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_VmExtends() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_VmExtends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmExtends(::grpc::ServerContext* context, const ::Qigrpc::requestVmExtends* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Test : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Test() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Test() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Test(::grpc::ServerContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTest(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HostInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_HostInfo() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_HostInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HostInfo(::grpc::ServerContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHostInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VmInstall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VmInstall() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_VmInstall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmInstall(::grpc::ServerContext* context, const ::Qigrpc::requestInstall* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmInstall(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VmCommon : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VmCommon() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_VmCommon() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmCommon(::grpc::ServerContext* context, const ::Qigrpc::requestSimple* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmCommon(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VmOperateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VmOperateSnapshot() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_VmOperateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmOperateSnapshot(::grpc::ServerContext* context, const ::Qigrpc::requestSnapshot* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmOperateSnapshot(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VmClone : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VmClone() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_VmClone() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmClone(::grpc::ServerContext* context, const ::Qigrpc::requestClone* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmClone(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VmImpAndExp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VmImpAndExp() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_VmImpAndExp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmImpAndExp(::grpc::ServerContext* context, const ::Qigrpc::requestImpAndexportVM* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmImpAndExp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VmNetwork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VmNetwork() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_VmNetwork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmNetwork(::grpc::ServerContext* context, const ::Qigrpc::requestNetwork* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmNetwork(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VmRdp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VmRdp() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_VmRdp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmRdp(::grpc::ServerContext* context, const ::Qigrpc::requestRdp* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmRdp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VmRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VmRecord() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_VmRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmRecord(::grpc::ServerContext* context, const ::Qigrpc::requestRecord* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmRecord(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VmSharefolder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VmSharefolder() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_VmSharefolder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmSharefolder(::grpc::ServerContext* context, const ::Qigrpc::requestSharefolder* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmSharefolder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VmConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VmConfig() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_VmConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmConfig(::grpc::ServerContext* context, const ::Qigrpc::requestConfig* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VmUSB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VmUSB() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_VmUSB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmUSB(::grpc::ServerContext* context, const ::Qigrpc::requestUSB* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmUSB(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VmAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VmAudio() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_VmAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmAudio(::grpc::ServerContext* context, const ::Qigrpc::requestAudio* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmAudio(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VmSerial : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VmSerial() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_VmSerial() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmSerial(::grpc::ServerContext* context, const ::Qigrpc::requestSerial* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmSerial(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_P2P : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_P2P() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_P2P() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2P(::grpc::ServerContext* context, const ::Qigrpc::requestP2P* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestP2P(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VmExtends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_VmExtends() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_VmExtends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmExtends(::grpc::ServerContext* context, const ::Qigrpc::requestVmExtends* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVmExtends(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Test : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Test() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Test(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Test() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Test(::grpc::ServerContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Test(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_HostInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_HostInfo() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->HostInfo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_HostInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HostInfo(::grpc::ServerContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void HostInfo(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VmInstall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VmInstall() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VmInstall(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VmInstall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmInstall(::grpc::ServerContext* context, const ::Qigrpc::requestInstall* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmInstall(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VmCommon : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VmCommon() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VmCommon(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VmCommon() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmCommon(::grpc::ServerContext* context, const ::Qigrpc::requestSimple* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmCommon(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VmOperateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VmOperateSnapshot() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VmOperateSnapshot(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VmOperateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmOperateSnapshot(::grpc::ServerContext* context, const ::Qigrpc::requestSnapshot* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmOperateSnapshot(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VmClone : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VmClone() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VmClone(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VmClone() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmClone(::grpc::ServerContext* context, const ::Qigrpc::requestClone* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmClone(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VmImpAndExp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VmImpAndExp() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VmImpAndExp(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VmImpAndExp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmImpAndExp(::grpc::ServerContext* context, const ::Qigrpc::requestImpAndexportVM* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmImpAndExp(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VmNetwork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VmNetwork() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VmNetwork(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VmNetwork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmNetwork(::grpc::ServerContext* context, const ::Qigrpc::requestNetwork* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmNetwork(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VmRdp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VmRdp() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VmRdp(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VmRdp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmRdp(::grpc::ServerContext* context, const ::Qigrpc::requestRdp* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmRdp(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VmRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VmRecord() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VmRecord(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VmRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmRecord(::grpc::ServerContext* context, const ::Qigrpc::requestRecord* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmRecord(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VmSharefolder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VmSharefolder() {
      ::grpc::Service::experimental().MarkMethodRawCallback(10,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VmSharefolder(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VmSharefolder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmSharefolder(::grpc::ServerContext* context, const ::Qigrpc::requestSharefolder* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmSharefolder(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VmConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VmConfig() {
      ::grpc::Service::experimental().MarkMethodRawCallback(11,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VmConfig(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VmConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmConfig(::grpc::ServerContext* context, const ::Qigrpc::requestConfig* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmConfig(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VmUSB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VmUSB() {
      ::grpc::Service::experimental().MarkMethodRawCallback(12,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VmUSB(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VmUSB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmUSB(::grpc::ServerContext* context, const ::Qigrpc::requestUSB* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmUSB(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VmAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VmAudio() {
      ::grpc::Service::experimental().MarkMethodRawCallback(13,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VmAudio(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VmAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmAudio(::grpc::ServerContext* context, const ::Qigrpc::requestAudio* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmAudio(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VmSerial : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VmSerial() {
      ::grpc::Service::experimental().MarkMethodRawCallback(14,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VmSerial(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VmSerial() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmSerial(::grpc::ServerContext* context, const ::Qigrpc::requestSerial* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmSerial(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_P2P : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_P2P() {
      ::grpc::Service::experimental().MarkMethodRawCallback(15,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->P2P(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_P2P() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status P2P(::grpc::ServerContext* context, const ::Qigrpc::requestP2P* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void P2P(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VmExtends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_VmExtends() {
      ::grpc::Service::experimental().MarkMethodRawCallback(16,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->VmExtends(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_VmExtends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VmExtends(::grpc::ServerContext* context, const ::Qigrpc::requestVmExtends* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void VmExtends(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Test : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Test() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::Qigrpc::requestNull, ::Qigrpc::vcaReply>(std::bind(&WithStreamedUnaryMethod_Test<BaseClass>::StreamedTest, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Test() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Test(::grpc::ServerContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTest(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Qigrpc::requestNull,::Qigrpc::vcaReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HostInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_HostInfo() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::Qigrpc::requestNull, ::Qigrpc::vcaReply>(std::bind(&WithStreamedUnaryMethod_HostInfo<BaseClass>::StreamedHostInfo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_HostInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HostInfo(::grpc::ServerContext* context, const ::Qigrpc::requestNull* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHostInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Qigrpc::requestNull,::Qigrpc::vcaReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VmInstall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VmInstall() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::Qigrpc::requestInstall, ::Qigrpc::vcaReply>(std::bind(&WithStreamedUnaryMethod_VmInstall<BaseClass>::StreamedVmInstall, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VmInstall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VmInstall(::grpc::ServerContext* context, const ::Qigrpc::requestInstall* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVmInstall(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Qigrpc::requestInstall,::Qigrpc::vcaReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VmCommon : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VmCommon() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::Qigrpc::requestSimple, ::Qigrpc::vcaReply>(std::bind(&WithStreamedUnaryMethod_VmCommon<BaseClass>::StreamedVmCommon, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VmCommon() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VmCommon(::grpc::ServerContext* context, const ::Qigrpc::requestSimple* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVmCommon(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Qigrpc::requestSimple,::Qigrpc::vcaReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VmOperateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VmOperateSnapshot() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::Qigrpc::requestSnapshot, ::Qigrpc::vcaReply>(std::bind(&WithStreamedUnaryMethod_VmOperateSnapshot<BaseClass>::StreamedVmOperateSnapshot, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VmOperateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VmOperateSnapshot(::grpc::ServerContext* context, const ::Qigrpc::requestSnapshot* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVmOperateSnapshot(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Qigrpc::requestSnapshot,::Qigrpc::vcaReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VmClone : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VmClone() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::Qigrpc::requestClone, ::Qigrpc::vcaReply>(std::bind(&WithStreamedUnaryMethod_VmClone<BaseClass>::StreamedVmClone, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VmClone() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VmClone(::grpc::ServerContext* context, const ::Qigrpc::requestClone* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVmClone(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Qigrpc::requestClone,::Qigrpc::vcaReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VmImpAndExp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VmImpAndExp() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::Qigrpc::requestImpAndexportVM, ::Qigrpc::vcaReply>(std::bind(&WithStreamedUnaryMethod_VmImpAndExp<BaseClass>::StreamedVmImpAndExp, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VmImpAndExp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VmImpAndExp(::grpc::ServerContext* context, const ::Qigrpc::requestImpAndexportVM* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVmImpAndExp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Qigrpc::requestImpAndexportVM,::Qigrpc::vcaReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VmNetwork : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VmNetwork() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::Qigrpc::requestNetwork, ::Qigrpc::vcaReply>(std::bind(&WithStreamedUnaryMethod_VmNetwork<BaseClass>::StreamedVmNetwork, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VmNetwork() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VmNetwork(::grpc::ServerContext* context, const ::Qigrpc::requestNetwork* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVmNetwork(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Qigrpc::requestNetwork,::Qigrpc::vcaReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VmRdp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VmRdp() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::Qigrpc::requestRdp, ::Qigrpc::vcaReply>(std::bind(&WithStreamedUnaryMethod_VmRdp<BaseClass>::StreamedVmRdp, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VmRdp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VmRdp(::grpc::ServerContext* context, const ::Qigrpc::requestRdp* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVmRdp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Qigrpc::requestRdp,::Qigrpc::vcaReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VmRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VmRecord() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::Qigrpc::requestRecord, ::Qigrpc::vcaReply>(std::bind(&WithStreamedUnaryMethod_VmRecord<BaseClass>::StreamedVmRecord, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VmRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VmRecord(::grpc::ServerContext* context, const ::Qigrpc::requestRecord* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVmRecord(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Qigrpc::requestRecord,::Qigrpc::vcaReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VmSharefolder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VmSharefolder() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::Qigrpc::requestSharefolder, ::Qigrpc::vcaReply>(std::bind(&WithStreamedUnaryMethod_VmSharefolder<BaseClass>::StreamedVmSharefolder, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VmSharefolder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VmSharefolder(::grpc::ServerContext* context, const ::Qigrpc::requestSharefolder* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVmSharefolder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Qigrpc::requestSharefolder,::Qigrpc::vcaReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VmConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VmConfig() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::Qigrpc::requestConfig, ::Qigrpc::vcaReply>(std::bind(&WithStreamedUnaryMethod_VmConfig<BaseClass>::StreamedVmConfig, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VmConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VmConfig(::grpc::ServerContext* context, const ::Qigrpc::requestConfig* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVmConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Qigrpc::requestConfig,::Qigrpc::vcaReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VmUSB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VmUSB() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::Qigrpc::requestUSB, ::Qigrpc::vcaReply>(std::bind(&WithStreamedUnaryMethod_VmUSB<BaseClass>::StreamedVmUSB, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VmUSB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VmUSB(::grpc::ServerContext* context, const ::Qigrpc::requestUSB* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVmUSB(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Qigrpc::requestUSB,::Qigrpc::vcaReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VmAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VmAudio() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::Qigrpc::requestAudio, ::Qigrpc::vcaReply>(std::bind(&WithStreamedUnaryMethod_VmAudio<BaseClass>::StreamedVmAudio, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VmAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VmAudio(::grpc::ServerContext* context, const ::Qigrpc::requestAudio* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVmAudio(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Qigrpc::requestAudio,::Qigrpc::vcaReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VmSerial : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VmSerial() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::Qigrpc::requestSerial, ::Qigrpc::vcaReply>(std::bind(&WithStreamedUnaryMethod_VmSerial<BaseClass>::StreamedVmSerial, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VmSerial() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VmSerial(::grpc::ServerContext* context, const ::Qigrpc::requestSerial* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVmSerial(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Qigrpc::requestSerial,::Qigrpc::vcaReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_P2P : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_P2P() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::Qigrpc::requestP2P, ::Qigrpc::vcaReply>(std::bind(&WithStreamedUnaryMethod_P2P<BaseClass>::StreamedP2P, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_P2P() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status P2P(::grpc::ServerContext* context, const ::Qigrpc::requestP2P* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedP2P(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Qigrpc::requestP2P,::Qigrpc::vcaReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VmExtends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_VmExtends() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::Qigrpc::requestVmExtends, ::Qigrpc::vcaReply>(std::bind(&WithStreamedUnaryMethod_VmExtends<BaseClass>::StreamedVmExtends, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_VmExtends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VmExtends(::grpc::ServerContext* context, const ::Qigrpc::requestVmExtends* request, ::Qigrpc::vcaReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVmExtends(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Qigrpc::requestVmExtends,::Qigrpc::vcaReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Test<WithStreamedUnaryMethod_HostInfo<WithStreamedUnaryMethod_VmInstall<WithStreamedUnaryMethod_VmCommon<WithStreamedUnaryMethod_VmOperateSnapshot<WithStreamedUnaryMethod_VmClone<WithStreamedUnaryMethod_VmImpAndExp<WithStreamedUnaryMethod_VmNetwork<WithStreamedUnaryMethod_VmRdp<WithStreamedUnaryMethod_VmRecord<WithStreamedUnaryMethod_VmSharefolder<WithStreamedUnaryMethod_VmConfig<WithStreamedUnaryMethod_VmUSB<WithStreamedUnaryMethod_VmAudio<WithStreamedUnaryMethod_VmSerial<WithStreamedUnaryMethod_P2P<WithStreamedUnaryMethod_VmExtends<Service > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Test<WithStreamedUnaryMethod_HostInfo<WithStreamedUnaryMethod_VmInstall<WithStreamedUnaryMethod_VmCommon<WithStreamedUnaryMethod_VmOperateSnapshot<WithStreamedUnaryMethod_VmClone<WithStreamedUnaryMethod_VmImpAndExp<WithStreamedUnaryMethod_VmNetwork<WithStreamedUnaryMethod_VmRdp<WithStreamedUnaryMethod_VmRecord<WithStreamedUnaryMethod_VmSharefolder<WithStreamedUnaryMethod_VmConfig<WithStreamedUnaryMethod_VmUSB<WithStreamedUnaryMethod_VmAudio<WithStreamedUnaryMethod_VmSerial<WithStreamedUnaryMethod_P2P<WithStreamedUnaryMethod_VmExtends<Service > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace Qigrpc


#endif  // GRPC_qigrpc_2eproto__INCLUDED
